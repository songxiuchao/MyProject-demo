收集器:
1.serial收集器
单线程，工作时必须暂停其他工作线程。多用于client机器上，使用复制算法
2.ParNew收集器
serial收集器的多线程版本，server模式下虚拟机首选的新生代收集器。复制算法
3.Parallel Scavenge收集器
复制算法，可控制吞吐量的收集器。吞吐量即有效运行时间。
4.Serial Old收集器
serial的老年代版本，使用整理算法。
5.Parallel Old收集器
第三种收集器的老年代版本，多线程，标记整理
6.CMS收集器
目标是最短回收停顿时间。
标记清除算法实现，分四个阶段：


初始标记：GC Roots直连的对象做标记
并发标记：
多线程方式GC Roots Tracing
重新标记：
修正第二阶段标记的记录
并发清除。

缺点：标记清除算法的缺点(无法处理浮动的垃圾)，产生碎片。CPU资源敏感。

7.G1垃圾收集算法主要应用在多CPU大内存的服务中，在满足高吞吐量的同时，
尽可能的满足垃圾回收时的暂停时间，该设计主要针对如下应用场景：
垃圾收集线程和应用线程并发执行，和CMS一样
空闲内存压缩时避免冗长的暂停时间
应用需要更多可预测的GC暂停时间
不希望牺牲太多的吞吐性能
不需要很大的Java堆 （翻译的有点虚，多大才算大？）


回收过程:
1.引用计数法 无法解决循环引用的问题
2.可达性分析法 ：在第一次标记之后会进行一次筛选，
筛选的条件是此对象有没有覆写 Object类的finalize() 方法，
如果覆写了并且没执行过，那就执行finalize方法，
如果在执行过程中，该对象和GC Roots对象可达则可逃离一次死亡，
如果没有覆写或者覆写了已经被执行过了，那么该对象直接死亡


垃圾回收算法
1.标记清除
2.复制算法

JVM组成部分：
类加载子系统，运行时数据区（内存结构），执行引擎

类加载机制：
全盘负责委派机制，双亲委派机制

如何判断一个类是无用的类：
1）该类所有实例已经被回收，即堆中不存在该类的任何实例变量
2）加载该类的ClassLoader已经被回收
3）该类对应的java.lang.Class对象没有在任何地方引用，任何对方无法通过反射找到该类的方法

































































