AVL：自平衡二叉查找树
任意节点的左子树深度和右子树深度相差不会超过1 如图：! [avator](pic/AVL.png)
时间复杂度：
1)插入:O(1)。只需要一次或者两次旋转来维持平衡。
2)删除:O(logN)。最差的情况就要每层的节点进行树旋转，所以时间复杂度为O(logN)。
3)查询：O(logN)。


红黑树:
每个节点都带有颜色属性的二叉查找树，颜色为红色和黑色。如图[avator](pic/红黑树.png)
节点是红色或黑色。
根是黑色。
所有nill节点都是黑色。
从每个叶子到根的所有路径上不能有两个连续的红色节点。
从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
时间复杂度:
1)插入：O(1)。在一些插入情形，红黑树最多只要*两次*旋转就能保持其性质。
但是在只需要更改颜色就能保持颜色的情形下，红黑树可能需要logN次变换颜色才能保持其性质。
但是变换颜色的需要的开销远远小于树旋转的开销，所以算作O(1)。
2)删除：O(1)。 同插入，最多*三次*旋转就能保持其性质。
3)插入：O(logN)。


Tire树: 如图: [avator](pic/Tire.png)
trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。
与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。
一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。
一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值

总结：
trie树死在了开始，无疑AVL树在查询方面是最出色的，但是在删除的时候可能会引起噩梦，
红黑树，虽然他牺牲了一部分查询性能，但是使删除性能在大部分情况保持了常数的时间复杂度。
但是，有一个最重要的问题是，mysql的数据是放在外部存储的，也就是说磁盘IO才是性能瓶颈的关键，
所以我们需要的是减少树的深度，所以我们需要更多分叉的树 ,还需要更适合磁盘操作特性的数据结构。


B树（B-树）是一种多路搜索树（并不是二叉的）如图: [avator](pic/B树.png)
1.定义任意非叶子结点最多只有M个儿子；且M>2；
2.根结点的儿子数为[2, M]；
3.除根结点以外的非叶子结点的儿子数为[M/2, M]；
4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
5.非叶子结点的关键字个数=指向儿子的指针个数-1；
6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的
子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
8.所有叶子结点位于同一层；
B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果
命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；


B-树的特性：如图: [avator](pic/B-树.png)
1.关键字集合分布在整颗树中；
2.任何一个关键字出现且只出现在一个结点中；
3.搜索有可能在非叶子结点结束；
4.其搜索性能等价于在关键字全集内做一次二分查找；
5.自动层次控制；
由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：
其中，M为设定的非叶子结点最多子树个数，N为关键字总数；
所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；
由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占
M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；

 

 

B+树 B+树是B-树的变体，也是一种多路搜索树 ，如图: [avator](pic/B+树.png)
1.其定义基本与B-树同，除了：
2.非叶子结点的子树指针与关键字个数相同；
3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树
（B-树是开区间）；
5.为所有叶子结点增加一个链指针；
6.所有关键字都在叶子结点出现；
B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），
其性能也等价于在关键字全集做一次二分查找；
B+的特性：
1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
2.不可能在非叶子结点命中；
3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
4.更适合文件索引系统；


B*树 如图: [avator](pic/B※树.png)
是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；
B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3
（代替B+树的1/2）；
B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据
复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父
结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；
B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分
数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字
（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之
间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；
所以，B*树分配新结点的概率比B+树要低，空间使用率更高；


小结
二叉搜索树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于
走右结点；
B（B-）树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键
字范围的子结点；
所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点
中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率
从1/2提高到2/3；









































